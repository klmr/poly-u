#!/usr/bin/env Rscript

sys = modules::import('klmr/sys')

sys$run({
    args = sys$cmd$parse(opt('r', 'reference', 'top-level reference sequence file (fasta)'),
                         opt('a', 'annotation', 'gene reference annotation (GTF)'),
                         opt('j', 'ncores', 'number of cores to use', 1L),
                         arg('genes', 'ID–gene name map file'),
                         arg('fastq', '3ʹ end sequence file'))

    io = modules::import('ebi-predocs/ebits/io')
    sr = modules::import_package('ShortRead')
    rtl = modules::import_package('rtracklayer')
    sam = modules::import_package('Rsamtools')
    gr = modules::import_package('GenomicRanges')
    dplyr = modules::import_package('dplyr', attach = TRUE)
    bios = modules::import_package('Biostrings')
    modules::import('klmr/functional/lambda')

    genes = io$read_table(args$genes) %>%
        select(ReadID = 1, Gene = 2)

    # Load 3ʹ reads for which 5ʹ reads are mapped successfully.
    seq_3p = sr$readFastq(args$fastq)
    matching_3p = match(genes$ReadID, as.character(sr$id(seq_3p)))
    seq_3p = seq_3p[matching_3p]

    # Load annotation of genes with corresponding 5ʹ reads.
    annotation = rtl$import(args$annotation)
    # Ensure only gene annotations are loaded …
    meta = {} -> gr$elementMetadata(annotation)
    annotation = annotation[meta()$type == 'gene']
    annotation = annotation[match(genes$Gene, meta()$gene_id)]

    stopifnot(length(annotation) == length(seq_3p))

    # Filter non-interesting reads.
    protein_coding = meta()$gene_biotype == 'protein_coding'
    annotation = annotation[protein_coding]
    seq_3p = seq_3p[protein_coding]
    reads_3p = bios$reverseComplement(sr$sread(seq_3p))

    read_length = gr$width(reads_3p)[1]

    flank_3p_annotation = gr$resize(gr$flank(annotation, 200, FALSE),
                                    200 + read_length)
    flank_3p_seq = sam$getSeq(sam$FaFile(args$reference), flank_3p_annotation)

    mat = bios$nucleotideSubstitutionMatrix(match = 1, mismatch = -4, baseOnly = TRUE)

    alignments = bios$pairwiseAlignment(reads_3p, flank_3p_seq, type = 'local',
                                        substitutionMatrix = mat,
                                        gapOpening = 20, gapExtension = 20)

    # Proper alignments that are anchored at 3ʹ must end after the end of the
    # gene (i.e. at position >= read_length) because otherwise they end within
    # the gene body. Ending AFTER the gene body is fine, since there may be a 3ʹ
    # UTR in the read.

    valid_alignments = gr$end(alignments@subject@range) >= read_length
    alignments = alignments[valid_alignments]
    align_names = as.character(sr$id(seq_3p[valid_alignments]))

    # Furthermore, we want alignments that continue with `A…` in the pattern.

    pattern = alignments@pattern
    read_tails = substr(pattern@unaligned, gr$end(pattern@range) + 1,
                        gr$width(pattern@unaligned)) %>%
        setNames(align_names)

    read_tails = read_tails[substr(read_tails, 1, 1) == 'A']
    tail_runs = lapply(strsplit(read_tails, ''), rle)
    poly_a_lengths = vapply(tail_runs, x -> x$lengths[1], 0L)
})

# vim: ft=r
