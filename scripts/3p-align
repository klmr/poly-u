#!/usr/bin/env Rscript

sys = modules::import('klmr/sys')

# Equivalent to `mpi.collate.pairwiseAlignment`, cf. [1], with some fixes.
# [1]: https://github.com/genome-vendor/r-bioc-biostrings/blob/bb531fe42544beb2c5f5f4a41985ee4023553136/R/pairwiseAlignment.R#L300-L316
mc_collate = function (results, pattern, subject) {
    value = results[[1]]
    value@score = unlist(lapply(results, bios$score))

    lapply = {...} -> unname(base::lapply(...))

    value@pattern@unaligned@pool = pattern@pool
    value@pattern@unaligned@ranges = pattern@ranges
    value@pattern@range = do.call(c, lapply(results, x -> x@pattern@range))
    value@pattern@mismatch = do.call(c, lapply(results, x -> x@pattern@mismatch))
    value@pattern@indel =  do.call(c, lapply(results, x -> x@pattern@indel))

    value@subject@unaligned@pool = subject@pool
    value@subject@unaligned@ranges = subject@ranges
    value@subject@range = do.call(c, lapply(results, x -> x@subject@range))
    value@subject@mismatch = do.call(c, lapply(results, x -> x@subject@mismatch))
    value@subject@indel = do.call(c, lapply(results, x -> x@subject@indel))

    value
}

sys$run({
    args = sys$cmd$parse(opt('r', 'reference', 'top-level reference sequence file (fasta)'),
                         opt('a', 'annotation', 'gene reference annotation (GTF)'),
                         opt('j', 'ncores', 'number of cores to use', 1L),
                         arg('genes', 'ID–gene name map file'),
                         arg('fastq', '3ʹ end sequence file'))

    io = modules::import('ebi-predocs/ebits/io')
    sr = modules::import_package('ShortRead')
    rtl = modules::import_package('rtracklayer')
    sam = modules::import_package('Rsamtools')
    gr = modules::import_package('GenomicRanges')
    dplyr = modules::import_package('dplyr', attach = TRUE)
    bios = modules::import_package('Biostrings')
    modules::import('klmr/functional/lambda')

    genes = io$read_table(args$genes) %>%
        select(ReadID = 1, Gene = 2)

    # Load 3ʹ reads for which 5ʹ reads are mapped successfully.
    seq_3p = sr$readFastq(args$fastq)
    seq_3p = seq_3p[match(genes$ReadID, as.character(sr$id(seq_3p)))]

    # Load annotation of genes with corresponding 5ʹ reads.
    annotation = rtl$import(args$annotation)
    # Ensure only gene annotations are loaded …
    annotation = annotation[annotation$type == 'gene']
    annotation = annotation[match(genes$Gene, annotation$gene_id)]

    stopifnot(length(annotation) == length(seq_3p))

    # Filter non-interesting reads.
    protein_coding = annotation$gene_biotype == 'protein_coding'
    annotation = annotation[protein_coding]
    seq_3p = seq_3p[protein_coding]
    reads_3p = bios$reverseComplement(sr$sread(seq_3p))

    flank_3p_annotation = annotation %>%
        gr$flank(2000, FALSE) %>%
        gr$resize(2000 + gr$width(reads_3p), 'end')
    reference = sam$FaFile(args$reference)
    seqlengths = GenomeInfoDb::seqlengths(reference)

    constrain = function (annotation, lengths) {
        # Necessary because `gr$start(annotation) = …` doesn’t work:
        # “invalid function in complex assignment”
        modules::import_package('GenomicRanges', attach = TRUE)
        start(annotation) = pmax(1L, start(annotation))
        lengths = lengths[as.character(gr$seqnames(annotation))]
        end(annotation) = pmin(end(annotation), lengths)
        annotation
    }

    flank_3p_annotation = constrain(flank_3p_annotation, seqlengths)
    flank_3p_seq = sam$getSeq(reference, flank_3p_annotation)

    mat = bios$nucleotideSubstitutionMatrix(match = 1, mismatch = -4)

    # Multicore setup.
    indices = seq_along(reads_3p)
    segments = split(indices, cut(indices, args$ncores, labels = FALSE))

    do_alignment = function (indices) {
        bios$pairwiseAlignment(reads_3p[indices],
                               flank_3p_seq[indices],
                               type = 'local',
                               substitutionMatrix = mat,
                               gapOpening = 20, gapExtension = 20)
    }

    # FIXME: Doesn’t work yet (klmr/modules#62)
    # modules::import_package('parallel', attach = 'mclapply')
    mclapply = modules::import_package('parallel')$mclapply

    alignments = mclapply(segments, do_alignment, mc.cores = args$ncores) %>%
        mc_collate(reads_3p, flank_3p_seq)

    # Proper alignments that are anchored at 3ʹ must end after the end of the
    # gene (i.e. at position >= read_length) because otherwise they end within
    # the gene body. Ending AFTER the gene body is fine, since there may be a 3ʹ
    # UTR in the read.

    valid_alignments = gr$end(alignments@subject@range) >= read_length
    alignments = alignments[valid_alignments]
    align_names = as.character(sr$id(seq_3p[valid_alignments]))

    # Furthermore, we want alignments that continue with `A…` in the pattern.

    pattern = alignments@pattern
    read_tails = substr(pattern@unaligned, gr$end(pattern@range) + 1,
                        gr$width(pattern@unaligned)) %>%
        setNames(align_names)

    tail_runs = lapply(strsplit(read_tails, ''), rle)
    poly_a_lengths = vapply(tail_runs, x -> x$lengths[1], integer(1))
    next_mods = vapply(tail_runs, x -> x$values[2], character(1))
    next_mod_lengths = vapply(tail_runs, x -> x$lengths[2], integer(1))

    # FIXME: Doesn’t work yet (klmr/modules#62)
    #modules::import_package('tibble', attach = 'data_frame')
    data_frame = modules::import_package('tibble')$data_frame
    result = data_frame(Name = names(read_tails),
                        Gene = genes$Gene[match(names(read_tails), genes$ReadID)],
                        `Length (pA)` = poly_a_lengths,
                        Mod = next_mods,
                        `Length (mod)` = next_mod_lengths)

    write.table(result, file = stdout(),
                quote = FALSE, sep = '\t', row.names = FALSE)
})

# vim: ft=r
